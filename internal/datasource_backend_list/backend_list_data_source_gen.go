// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_backend_list

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func BackendListDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Computed: true,
			},
			"fields": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
				MarkdownDescription: "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
			},
			"filter": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "an EQL \"where\" expression that will be used to filter the set of resources returned.",
				MarkdownDescription: "an EQL \"where\" expression that will be used to filter the set of resources returned.",
			},
			"items": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"api_version": schema.StringAttribute{
							Computed: true,
						},
						"kind": schema.StringAttribute{
							Computed: true,
						},
						"metadata": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"annotations": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"labels": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"namespace": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: MetadataType{
								ObjectType: types.ObjectType{
									AttrTypes: MetadataValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"spec": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"asn_pool": schema.StringAttribute{
									Optional:            true,
									Description:         "Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  Used when eBGP is configured as an underlay protocol.",
									MarkdownDescription: "Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  Used when eBGP is configured as an underlay protocol.",
								},
								"gpu_isolation_groups": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"interface_selector": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
											"name": schema.StringAttribute{
												Optional:            true,
												Description:         "Name of the IsolationGroup.",
												MarkdownDescription: "Name of the IsolationGroup.",
											},
										},
										CustomType: GpuIsolationGroupsType{
											ObjectType: types.ObjectType{
												AttrTypes: GpuIsolationGroupsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "GPU Isolation Groups are used to isolate GPU traffic over the network, GPUs in different GPU isolation groups will not be able to communicate with each other.  If all GPUs across all stripes need to be able to communicate with each other, create a single GPUIsolationGroup selecting all GPU facing interfaces.",
									MarkdownDescription: "GPU Isolation Groups are used to isolate GPU traffic over the network, GPUs in different GPU isolation groups will not be able to communicate with each other.  If all GPUs across all stripes need to be able to communicate with each other, create a single GPUIsolationGroup selecting all GPU facing interfaces.",
								},
								"rocev2_qos": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"ecn_max_drop_probability_percent": schema.Int64Attribute{
											Optional:            true,
											Description:         "If the queue depth is between min and max threshold then this the probability with which packets are dropped or marked.",
											MarkdownDescription: "If the queue depth is between min and max threshold then this the probability with which packets are dropped or marked.",
										},
										"ecn_slope_max_threshold_percent": schema.Int64Attribute{
											Optional:            true,
											Description:         "The maximum threshold parameter for a RED-managed queue in percent. When the average queue length exceeds the max value, all packets are dropped (or marked if ECN is enabled). Mutually exclusive with min-threshold and max-threshold.",
											MarkdownDescription: "The maximum threshold parameter for a RED-managed queue in percent. When the average queue length exceeds the max value, all packets are dropped (or marked if ECN is enabled). Mutually exclusive with min-threshold and max-threshold.",
										},
										"ecn_slope_min_threshold_percent": schema.Int64Attribute{
											Optional:            true,
											Description:         "The mininum threshold parameter for a RED-managed queue in percent. When the average queue length is less than min, all packets are admitted to the queue. Mutually exclusive with min-threshold and max-threshold.",
											MarkdownDescription: "The mininum threshold parameter for a RED-managed queue in percent. When the average queue length is less than min, all packets are admitted to the queue. Mutually exclusive with min-threshold and max-threshold.",
										},
										"pfc_deadlock_detection_timer": schema.Int64Attribute{
											Optional:            true,
											Description:         "Number of milliseconds during which outgoing interface is receiving pfc-pause-frames before triggering recovery-timer.",
											MarkdownDescription: "Number of milliseconds during which outgoing interface is receiving pfc-pause-frames before triggering recovery-timer.",
										},
										"pfc_deadlock_recovery_timer": schema.Int64Attribute{
											Optional:            true,
											Description:         "Number of milliseconds during which the pfc-pause-frames will be ignored.",
											MarkdownDescription: "Number of milliseconds during which the pfc-pause-frames will be ignored.",
										},
										"queue_maximum_burst_size": schema.Int64Attribute{
											Optional:            true,
											Description:         "Maximum amount of shared buffer memory available to the queue in bytes.",
											MarkdownDescription: "Maximum amount of shared buffer memory available to the queue in bytes.",
										},
									},
									CustomType: Rocev2QosType{
										ObjectType: types.ObjectType{
											AttrTypes: Rocev2QosValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Set of properties to configure the RoCEv2 QoS.",
									MarkdownDescription: "Set of properties to configure the RoCEv2 QoS.",
								},
								"stripe_connector": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"asn_pool": schema.StringAttribute{
											Optional:            true,
											Description:         "Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.",
											MarkdownDescription: "Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.",
										},
										"link_selector": schema.ListAttribute{
											ElementType:         types.StringType,
											Optional:            true,
											Description:         "Selects TopoLinks to include in this AI Fabric, the selected TopoLinks will be used to create ISLs between the stripe connector devices and the leaf devices.",
											MarkdownDescription: "Selects TopoLinks to include in this AI Fabric, the selected TopoLinks will be used to create ISLs between the stripe connector devices and the leaf devices.",
										},
										"name": schema.StringAttribute{
											Optional:            true,
											Description:         "The name of the Stripe Connector.",
											MarkdownDescription: "The name of the Stripe Connector.",
										},
										"node_selector": schema.ListAttribute{
											ElementType:         types.StringType,
											Optional:            true,
											Description:         "Node selector to select the nodes to be used for this stripe connector.",
											MarkdownDescription: "Node selector to select the nodes to be used for this stripe connector.",
										},
										"system_pool_ipv4": schema.StringAttribute{
											Optional:            true,
											Description:         "Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces for the stripe connector devices.  If not specified, the system will use the default IPAllocationPool.",
											MarkdownDescription: "Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces for the stripe connector devices.  If not specified, the system will use the default IPAllocationPool.",
										},
									},
									CustomType: StripeConnectorType{
										ObjectType: types.ObjectType{
											AttrTypes: StripeConnectorValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "StripeConnector is the spine layer interconnecting multiple stripes.",
									MarkdownDescription: "StripeConnector is the spine layer interconnecting multiple stripes.",
								},
								"stripes": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"asn_pool": schema.StringAttribute{
												Optional:            true,
												Description:         "Optional reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  If left blank, ASN allocation will be done from the ASNAllocationRange.",
												MarkdownDescription: "Optional reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  If left blank, ASN allocation will be done from the ASNAllocationRange.",
											},
											"gpu_vlan": schema.Int64Attribute{
												Optional:            true,
												Description:         "The VLAN used on interfaces facing the GPU servers.",
												MarkdownDescription: "The VLAN used on interfaces facing the GPU servers.",
											},
											"name": schema.StringAttribute{
												Optional:            true,
												Description:         "The name of the Stripe.",
												MarkdownDescription: "The name of the Stripe.",
											},
											"node_selector": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "Node selector to select the nodes to be used for this stripe.",
												MarkdownDescription: "Node selector to select the nodes to be used for this stripe.",
											},
											"stripe_id": schema.Int64Attribute{
												Optional:            true,
												Description:         "Unique ID for a stripe",
												MarkdownDescription: "Unique ID for a stripe",
											},
											"system_pool_ipv4": schema.StringAttribute{
												Optional:            true,
												Description:         "Optional reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces. If left blank, system IP allocation will be done from the SystemIPV4Subnet.",
												MarkdownDescription: "Optional reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces. If left blank, system IP allocation will be done from the SystemIPV4Subnet.",
											},
										},
										CustomType: StripesType{
											ObjectType: types.ObjectType{
												AttrTypes: StripesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "A list of stripes, stripes contain a set of nodes (rails).",
									MarkdownDescription: "A list of stripes, stripes contain a set of nodes (rails).",
								},
								"system_pool_ipv4": schema.StringAttribute{
									Optional:            true,
									Description:         "Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces.  If specified under the Leaf/Spine/Superspine/Borderleaf those will take precedence.",
									MarkdownDescription: "Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces.  If specified under the Leaf/Spine/Superspine/Borderleaf those will take precedence.",
								},
							},
							CustomType: SpecType{
								ObjectType: types.ObjectType{
									AttrTypes: SpecValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "BackendSpec defines the desired state of Backend",
							MarkdownDescription: "BackendSpec defines the desired state of Backend",
						},
						"status": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"health": schema.Int64Attribute{
									Computed:            true,
									Description:         "Indicates the health score of the Fabric.  The health score of the Fabric is determined by the aggregate health score of the resources emited by the Fabric such as ISL, DefaultRouteReflectors etc.",
									MarkdownDescription: "Indicates the health score of the Fabric.  The health score of the Fabric is determined by the aggregate health score of the resources emited by the Fabric such as ISL, DefaultRouteReflectors etc.",
								},
								"health_score_reason": schema.StringAttribute{
									Computed:            true,
									Description:         "Indicates the reason for the health score.",
									MarkdownDescription: "Indicates the reason for the health score.",
								},
								"last_change": schema.StringAttribute{
									Computed:            true,
									Description:         "The time when the state of the resource last changed.",
									MarkdownDescription: "The time when the state of the resource last changed.",
								},
								"operational_state": schema.StringAttribute{
									Computed:            true,
									Description:         "Operational state of the Fabric.  The operational state of the fabric is determined by monitoring the operational state of the following resources (if applicable): DefaultRouters, ISLs.",
									MarkdownDescription: "Operational state of the Fabric.  The operational state of the fabric is determined by monitoring the operational state of the following resources (if applicable): DefaultRouters, ISLs.",
								},
								"stripe_connector": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Computed:            true,
											Description:         "The name of the Stripe Connector.",
											MarkdownDescription: "The name of the Stripe Connector.",
										},
										"stripe_connector_nodes": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"node": schema.StringAttribute{
														Computed:            true,
														Description:         "Name of the TopoNode.",
														MarkdownDescription: "Name of the TopoNode.",
													},
													"operating_system": schema.StringAttribute{
														Computed:            true,
														Description:         "Operating system running on the node.",
														MarkdownDescription: "Operating system running on the node.",
													},
													"operating_system_version": schema.StringAttribute{
														Computed:            true,
														Description:         "Operating system version running on the node.",
														MarkdownDescription: "Operating system version running on the node.",
													},
												},
												CustomType: StripeConnectorNodesType{
													ObjectType: types.ObjectType{
														AttrTypes: StripeConnectorNodesValue{}.AttributeTypes(ctx),
													},
												},
											},
											Computed:            true,
											Description:         "List of stripe connector nodes in the Stripe.",
											MarkdownDescription: "List of stripe connector nodes in the Stripe.",
										},
									},
									CustomType: StripeConnector1Type{
										ObjectType: types.ObjectType{
											AttrTypes: StripeConnector1Value{}.AttributeTypes(ctx),
										},
									},
									Computed:            true,
									Description:         "Stripe connector in the Backend.",
									MarkdownDescription: "Stripe connector in the Backend.",
								},
								"stripes": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"leaf_nodes": schema.ListNestedAttribute{
												NestedObject: schema.NestedAttributeObject{
													Attributes: map[string]schema.Attribute{
														"node": schema.StringAttribute{
															Computed:            true,
															Description:         "Name of the TopoNode.",
															MarkdownDescription: "Name of the TopoNode.",
														},
														"operating_system": schema.StringAttribute{
															Computed:            true,
															Description:         "Operating system running on the node.",
															MarkdownDescription: "Operating system running on the node.",
														},
														"operating_system_version": schema.StringAttribute{
															Computed:            true,
															Description:         "Operating system version running on the node.",
															MarkdownDescription: "Operating system version running on the node.",
														},
													},
													CustomType: LeafNodesType{
														ObjectType: types.ObjectType{
															AttrTypes: LeafNodesValue{}.AttributeTypes(ctx),
														},
													},
												},
												Computed:            true,
												Description:         "List of leaf nodes in the Stripe.",
												MarkdownDescription: "List of leaf nodes in the Stripe.",
											},
											"name": schema.StringAttribute{
												Computed:            true,
												Description:         "The name of the Stripe.",
												MarkdownDescription: "The name of the Stripe.",
											},
										},
										CustomType: Stripes1Type{
											ObjectType: types.ObjectType{
												AttrTypes: Stripes1Value{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "List of stripes in the Backend.",
									MarkdownDescription: "List of stripes in the Backend.",
								},
							},
							CustomType: StatusType{
								ObjectType: types.ObjectType{
									AttrTypes: StatusValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "BackendStatus defines the observed state of Backend",
							MarkdownDescription: "BackendStatus defines the observed state of Backend",
						},
					},
					CustomType: ItemsType{
						ObjectType: types.ObjectType{
							AttrTypes: ItemsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"kind": schema.StringAttribute{
				Computed: true,
			},
			"label_selector": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "a label selector string to filter the results based on CR labels",
				MarkdownDescription: "a label selector string to filter the results based on CR labels",
			},
			"namespace": schema.StringAttribute{
				Required:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
		},
	}
}

type BackendListModel struct {
	ApiVersion    types.String `tfsdk:"api_version"`
	Fields        types.String `tfsdk:"fields"`
	Filter        types.String `tfsdk:"filter"`
	Items         types.List   `tfsdk:"items"`
	Kind          types.String `tfsdk:"kind"`
	LabelSelector types.String `tfsdk:"label_selector"`
	Namespace     types.String `tfsdk:"namespace"`
}

var _ basetypes.ObjectTypable = ItemsType{}

type ItemsType struct {
	basetypes.ObjectType
}

func (t ItemsType) Equal(o attr.Type) bool {
	other, ok := o.(ItemsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ItemsType) String() string {
	return "ItemsType"
}

func (t ItemsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiVersionAttribute, ok := attributes["api_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_version is missing from object`)

		return nil, diags
	}

	apiVersionVal, ok := apiVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_version expected to be basetypes.StringValue, was: %T`, apiVersionAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return nil, diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ObjectValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return nil, diags
	}

	specVal, ok := specAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ObjectValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ItemsValue{
		ApiVersion: apiVersionVal,
		Kind:       kindVal,
		Metadata:   metadataVal,
		Spec:       specVal,
		Status:     statusVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewItemsValueNull() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateNull,
	}
}

func NewItemsValueUnknown() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewItemsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ItemsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ItemsValue Attribute Value",
				"While creating a ItemsValue value, a missing attribute value was detected. "+
					"A ItemsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ItemsValue Attribute Type",
				"While creating a ItemsValue value, an invalid attribute value was detected. "+
					"A ItemsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ItemsValue Attribute Value",
				"While creating a ItemsValue value, an extra attribute value was detected. "+
					"A ItemsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ItemsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	apiVersionAttribute, ok := attributes["api_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_version is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	apiVersionVal, ok := apiVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_version expected to be basetypes.StringValue, was: %T`, apiVersionAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ObjectValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	specVal, ok := specAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ObjectValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	return ItemsValue{
		ApiVersion: apiVersionVal,
		Kind:       kindVal,
		Metadata:   metadataVal,
		Spec:       specVal,
		Status:     statusVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewItemsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ItemsValue {
	object, diags := NewItemsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewItemsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ItemsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewItemsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewItemsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewItemsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewItemsValueMust(ItemsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ItemsType) ValueType(ctx context.Context) attr.Value {
	return ItemsValue{}
}

var _ basetypes.ObjectValuable = ItemsValue{}

type ItemsValue struct {
	ApiVersion basetypes.StringValue `tfsdk:"api_version"`
	Kind       basetypes.StringValue `tfsdk:"kind"`
	Metadata   basetypes.ObjectValue `tfsdk:"metadata"`
	Spec       basetypes.ObjectValue `tfsdk:"spec"`
	Status     basetypes.ObjectValue `tfsdk:"status"`
	state      attr.ValueState
}

func (v ItemsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["api_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ObjectType{
		AttrTypes: MetadataValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: SpecValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.ObjectType{
		AttrTypes: StatusValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.ApiVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_version"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Metadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.Spec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ItemsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ItemsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ItemsValue) String() string {
	return "ItemsValue"
}

func (v ItemsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var metadata basetypes.ObjectValue

	if v.Metadata.IsNull() {
		metadata = types.ObjectNull(
			MetadataValue{}.AttributeTypes(ctx),
		)
	}

	if v.Metadata.IsUnknown() {
		metadata = types.ObjectUnknown(
			MetadataValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Metadata.IsNull() && !v.Metadata.IsUnknown() {
		metadata = types.ObjectValueMust(
			MetadataValue{}.AttributeTypes(ctx),
			v.Metadata.Attributes(),
		)
	}

	var spec basetypes.ObjectValue

	if v.Spec.IsNull() {
		spec = types.ObjectNull(
			SpecValue{}.AttributeTypes(ctx),
		)
	}

	if v.Spec.IsUnknown() {
		spec = types.ObjectUnknown(
			SpecValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec.IsNull() && !v.Spec.IsUnknown() {
		spec = types.ObjectValueMust(
			SpecValue{}.AttributeTypes(ctx),
			v.Spec.Attributes(),
		)
	}

	var status basetypes.ObjectValue

	if v.Status.IsNull() {
		status = types.ObjectNull(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if v.Status.IsUnknown() {
		status = types.ObjectUnknown(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Status.IsNull() && !v.Status.IsUnknown() {
		status = types.ObjectValueMust(
			StatusValue{}.AttributeTypes(ctx),
			v.Status.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"api_version": basetypes.StringType{},
		"kind":        basetypes.StringType{},
		"metadata": basetypes.ObjectType{
			AttrTypes: MetadataValue{}.AttributeTypes(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: SpecValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"api_version": v.ApiVersion,
			"kind":        v.Kind,
			"metadata":    metadata,
			"spec":        spec,
			"status":      status,
		})

	return objVal, diags
}

func (v ItemsValue) Equal(o attr.Value) bool {
	other, ok := o.(ItemsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApiVersion.Equal(other.ApiVersion) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Metadata.Equal(other.Metadata) {
		return false
	}

	if !v.Spec.Equal(other.Spec) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v ItemsValue) Type(ctx context.Context) attr.Type {
	return ItemsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ItemsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"api_version": basetypes.StringType{},
		"kind":        basetypes.StringType{},
		"metadata": basetypes.ObjectType{
			AttrTypes: MetadataValue{}.AttributeTypes(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: SpecValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asnPoolAttribute, ok := attributes["asn_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn_pool is missing from object`)

		return nil, diags
	}

	asnPoolVal, ok := asnPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn_pool expected to be basetypes.StringValue, was: %T`, asnPoolAttribute))
	}

	gpuIsolationGroupsAttribute, ok := attributes["gpu_isolation_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_isolation_groups is missing from object`)

		return nil, diags
	}

	gpuIsolationGroupsVal, ok := gpuIsolationGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_isolation_groups expected to be basetypes.ListValue, was: %T`, gpuIsolationGroupsAttribute))
	}

	rocev2QosAttribute, ok := attributes["rocev2_qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rocev2_qos is missing from object`)

		return nil, diags
	}

	rocev2QosVal, ok := rocev2QosAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rocev2_qos expected to be basetypes.ObjectValue, was: %T`, rocev2QosAttribute))
	}

	stripeConnectorAttribute, ok := attributes["stripe_connector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stripe_connector is missing from object`)

		return nil, diags
	}

	stripeConnectorVal, ok := stripeConnectorAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stripe_connector expected to be basetypes.ObjectValue, was: %T`, stripeConnectorAttribute))
	}

	stripesAttribute, ok := attributes["stripes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stripes is missing from object`)

		return nil, diags
	}

	stripesVal, ok := stripesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stripes expected to be basetypes.ListValue, was: %T`, stripesAttribute))
	}

	systemPoolIpv4Attribute, ok := attributes["system_pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv4 is missing from object`)

		return nil, diags
	}

	systemPoolIpv4Val, ok := systemPoolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv4 expected to be basetypes.StringValue, was: %T`, systemPoolIpv4Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		AsnPool:            asnPoolVal,
		GpuIsolationGroups: gpuIsolationGroupsVal,
		Rocev2Qos:          rocev2QosVal,
		StripeConnector:    stripeConnectorVal,
		Stripes:            stripesVal,
		SystemPoolIpv4:     systemPoolIpv4Val,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	asnPoolAttribute, ok := attributes["asn_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn_pool is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	asnPoolVal, ok := asnPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn_pool expected to be basetypes.StringValue, was: %T`, asnPoolAttribute))
	}

	gpuIsolationGroupsAttribute, ok := attributes["gpu_isolation_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_isolation_groups is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	gpuIsolationGroupsVal, ok := gpuIsolationGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_isolation_groups expected to be basetypes.ListValue, was: %T`, gpuIsolationGroupsAttribute))
	}

	rocev2QosAttribute, ok := attributes["rocev2_qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rocev2_qos is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	rocev2QosVal, ok := rocev2QosAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rocev2_qos expected to be basetypes.ObjectValue, was: %T`, rocev2QosAttribute))
	}

	stripeConnectorAttribute, ok := attributes["stripe_connector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stripe_connector is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	stripeConnectorVal, ok := stripeConnectorAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stripe_connector expected to be basetypes.ObjectValue, was: %T`, stripeConnectorAttribute))
	}

	stripesAttribute, ok := attributes["stripes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stripes is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	stripesVal, ok := stripesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stripes expected to be basetypes.ListValue, was: %T`, stripesAttribute))
	}

	systemPoolIpv4Attribute, ok := attributes["system_pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv4 is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	systemPoolIpv4Val, ok := systemPoolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv4 expected to be basetypes.StringValue, was: %T`, systemPoolIpv4Attribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		AsnPool:            asnPoolVal,
		GpuIsolationGroups: gpuIsolationGroupsVal,
		Rocev2Qos:          rocev2QosVal,
		StripeConnector:    stripeConnectorVal,
		Stripes:            stripesVal,
		SystemPoolIpv4:     systemPoolIpv4Val,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	AsnPool            basetypes.StringValue `tfsdk:"asn_pool"`
	GpuIsolationGroups basetypes.ListValue   `tfsdk:"gpu_isolation_groups"`
	Rocev2Qos          basetypes.ObjectValue `tfsdk:"rocev2_qos"`
	StripeConnector    basetypes.ObjectValue `tfsdk:"stripe_connector"`
	Stripes            basetypes.ListValue   `tfsdk:"stripes"`
	SystemPoolIpv4     basetypes.StringValue `tfsdk:"system_pool_ipv4"`
	state              attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["asn_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gpu_isolation_groups"] = basetypes.ListType{
		ElemType: GpuIsolationGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["rocev2_qos"] = basetypes.ObjectType{
		AttrTypes: Rocev2QosValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["stripe_connector"] = basetypes.ObjectType{
		AttrTypes: StripeConnectorValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["stripes"] = basetypes.ListType{
		ElemType: StripesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["system_pool_ipv4"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.AsnPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asn_pool"] = val

		val, err = v.GpuIsolationGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_isolation_groups"] = val

		val, err = v.Rocev2Qos.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rocev2_qos"] = val

		val, err = v.StripeConnector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stripe_connector"] = val

		val, err = v.Stripes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stripes"] = val

		val, err = v.SystemPoolIpv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_pool_ipv4"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	gpuIsolationGroups := types.ListValueMust(
		GpuIsolationGroupsType{
			basetypes.ObjectType{
				AttrTypes: GpuIsolationGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.GpuIsolationGroups.Elements(),
	)

	if v.GpuIsolationGroups.IsNull() {
		gpuIsolationGroups = types.ListNull(
			GpuIsolationGroupsType{
				basetypes.ObjectType{
					AttrTypes: GpuIsolationGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.GpuIsolationGroups.IsUnknown() {
		gpuIsolationGroups = types.ListUnknown(
			GpuIsolationGroupsType{
				basetypes.ObjectType{
					AttrTypes: GpuIsolationGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var rocev2Qos basetypes.ObjectValue

	if v.Rocev2Qos.IsNull() {
		rocev2Qos = types.ObjectNull(
			Rocev2QosValue{}.AttributeTypes(ctx),
		)
	}

	if v.Rocev2Qos.IsUnknown() {
		rocev2Qos = types.ObjectUnknown(
			Rocev2QosValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Rocev2Qos.IsNull() && !v.Rocev2Qos.IsUnknown() {
		rocev2Qos = types.ObjectValueMust(
			Rocev2QosValue{}.AttributeTypes(ctx),
			v.Rocev2Qos.Attributes(),
		)
	}

	var stripeConnector basetypes.ObjectValue

	if v.StripeConnector.IsNull() {
		stripeConnector = types.ObjectNull(
			StripeConnectorValue{}.AttributeTypes(ctx),
		)
	}

	if v.StripeConnector.IsUnknown() {
		stripeConnector = types.ObjectUnknown(
			StripeConnectorValue{}.AttributeTypes(ctx),
		)
	}

	if !v.StripeConnector.IsNull() && !v.StripeConnector.IsUnknown() {
		stripeConnector = types.ObjectValueMust(
			StripeConnectorValue{}.AttributeTypes(ctx),
			v.StripeConnector.Attributes(),
		)
	}

	stripes := types.ListValueMust(
		StripesType{
			basetypes.ObjectType{
				AttrTypes: StripesValue{}.AttributeTypes(ctx),
			},
		},
		v.Stripes.Elements(),
	)

	if v.Stripes.IsNull() {
		stripes = types.ListNull(
			StripesType{
				basetypes.ObjectType{
					AttrTypes: StripesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Stripes.IsUnknown() {
		stripes = types.ListUnknown(
			StripesType{
				basetypes.ObjectType{
					AttrTypes: StripesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"asn_pool": basetypes.StringType{},
		"gpu_isolation_groups": basetypes.ListType{
			ElemType: GpuIsolationGroupsValue{}.Type(ctx),
		},
		"rocev2_qos": basetypes.ObjectType{
			AttrTypes: Rocev2QosValue{}.AttributeTypes(ctx),
		},
		"stripe_connector": basetypes.ObjectType{
			AttrTypes: StripeConnectorValue{}.AttributeTypes(ctx),
		},
		"stripes": basetypes.ListType{
			ElemType: StripesValue{}.Type(ctx),
		},
		"system_pool_ipv4": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"asn_pool":             v.AsnPool,
			"gpu_isolation_groups": gpuIsolationGroups,
			"rocev2_qos":           rocev2Qos,
			"stripe_connector":     stripeConnector,
			"stripes":              stripes,
			"system_pool_ipv4":     v.SystemPoolIpv4,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsnPool.Equal(other.AsnPool) {
		return false
	}

	if !v.GpuIsolationGroups.Equal(other.GpuIsolationGroups) {
		return false
	}

	if !v.Rocev2Qos.Equal(other.Rocev2Qos) {
		return false
	}

	if !v.StripeConnector.Equal(other.StripeConnector) {
		return false
	}

	if !v.Stripes.Equal(other.Stripes) {
		return false
	}

	if !v.SystemPoolIpv4.Equal(other.SystemPoolIpv4) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"asn_pool": basetypes.StringType{},
		"gpu_isolation_groups": basetypes.ListType{
			ElemType: GpuIsolationGroupsValue{}.Type(ctx),
		},
		"rocev2_qos": basetypes.ObjectType{
			AttrTypes: Rocev2QosValue{}.AttributeTypes(ctx),
		},
		"stripe_connector": basetypes.ObjectType{
			AttrTypes: StripeConnectorValue{}.AttributeTypes(ctx),
		},
		"stripes": basetypes.ListType{
			ElemType: StripesValue{}.Type(ctx),
		},
		"system_pool_ipv4": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = GpuIsolationGroupsType{}

type GpuIsolationGroupsType struct {
	basetypes.ObjectType
}

func (t GpuIsolationGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(GpuIsolationGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GpuIsolationGroupsType) String() string {
	return "GpuIsolationGroupsType"
}

func (t GpuIsolationGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceSelectorAttribute, ok := attributes["interface_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_selector is missing from object`)

		return nil, diags
	}

	interfaceSelectorVal, ok := interfaceSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_selector expected to be basetypes.ListValue, was: %T`, interfaceSelectorAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GpuIsolationGroupsValue{
		InterfaceSelector: interfaceSelectorVal,
		Name:              nameVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewGpuIsolationGroupsValueNull() GpuIsolationGroupsValue {
	return GpuIsolationGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewGpuIsolationGroupsValueUnknown() GpuIsolationGroupsValue {
	return GpuIsolationGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGpuIsolationGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GpuIsolationGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GpuIsolationGroupsValue Attribute Value",
				"While creating a GpuIsolationGroupsValue value, a missing attribute value was detected. "+
					"A GpuIsolationGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GpuIsolationGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GpuIsolationGroupsValue Attribute Type",
				"While creating a GpuIsolationGroupsValue value, an invalid attribute value was detected. "+
					"A GpuIsolationGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GpuIsolationGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GpuIsolationGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GpuIsolationGroupsValue Attribute Value",
				"While creating a GpuIsolationGroupsValue value, an extra attribute value was detected. "+
					"A GpuIsolationGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GpuIsolationGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGpuIsolationGroupsValueUnknown(), diags
	}

	interfaceSelectorAttribute, ok := attributes["interface_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_selector is missing from object`)

		return NewGpuIsolationGroupsValueUnknown(), diags
	}

	interfaceSelectorVal, ok := interfaceSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_selector expected to be basetypes.ListValue, was: %T`, interfaceSelectorAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewGpuIsolationGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewGpuIsolationGroupsValueUnknown(), diags
	}

	return GpuIsolationGroupsValue{
		InterfaceSelector: interfaceSelectorVal,
		Name:              nameVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewGpuIsolationGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GpuIsolationGroupsValue {
	object, diags := NewGpuIsolationGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGpuIsolationGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GpuIsolationGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGpuIsolationGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGpuIsolationGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGpuIsolationGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGpuIsolationGroupsValueMust(GpuIsolationGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GpuIsolationGroupsType) ValueType(ctx context.Context) attr.Value {
	return GpuIsolationGroupsValue{}
}

var _ basetypes.ObjectValuable = GpuIsolationGroupsValue{}

type GpuIsolationGroupsValue struct {
	InterfaceSelector basetypes.ListValue   `tfsdk:"interface_selector"`
	Name              basetypes.StringValue `tfsdk:"name"`
	state             attr.ValueState
}

func (v GpuIsolationGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["interface_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.InterfaceSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_selector"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GpuIsolationGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GpuIsolationGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GpuIsolationGroupsValue) String() string {
	return "GpuIsolationGroupsValue"
}

func (v GpuIsolationGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var interfaceSelectorVal basetypes.ListValue
	switch {
	case v.InterfaceSelector.IsUnknown():
		interfaceSelectorVal = types.ListUnknown(types.StringType)
	case v.InterfaceSelector.IsNull():
		interfaceSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		interfaceSelectorVal, d = types.ListValue(types.StringType, v.InterfaceSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"interface_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"name": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"interface_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface_selector": interfaceSelectorVal,
			"name":               v.Name,
		})

	return objVal, diags
}

func (v GpuIsolationGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(GpuIsolationGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InterfaceSelector.Equal(other.InterfaceSelector) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v GpuIsolationGroupsValue) Type(ctx context.Context) attr.Type {
	return GpuIsolationGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GpuIsolationGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Rocev2QosType{}

type Rocev2QosType struct {
	basetypes.ObjectType
}

func (t Rocev2QosType) Equal(o attr.Type) bool {
	other, ok := o.(Rocev2QosType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Rocev2QosType) String() string {
	return "Rocev2QosType"
}

func (t Rocev2QosType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ecnMaxDropProbabilityPercentAttribute, ok := attributes["ecn_max_drop_probability_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ecn_max_drop_probability_percent is missing from object`)

		return nil, diags
	}

	ecnMaxDropProbabilityPercentVal, ok := ecnMaxDropProbabilityPercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ecn_max_drop_probability_percent expected to be basetypes.Int64Value, was: %T`, ecnMaxDropProbabilityPercentAttribute))
	}

	ecnSlopeMaxThresholdPercentAttribute, ok := attributes["ecn_slope_max_threshold_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ecn_slope_max_threshold_percent is missing from object`)

		return nil, diags
	}

	ecnSlopeMaxThresholdPercentVal, ok := ecnSlopeMaxThresholdPercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ecn_slope_max_threshold_percent expected to be basetypes.Int64Value, was: %T`, ecnSlopeMaxThresholdPercentAttribute))
	}

	ecnSlopeMinThresholdPercentAttribute, ok := attributes["ecn_slope_min_threshold_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ecn_slope_min_threshold_percent is missing from object`)

		return nil, diags
	}

	ecnSlopeMinThresholdPercentVal, ok := ecnSlopeMinThresholdPercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ecn_slope_min_threshold_percent expected to be basetypes.Int64Value, was: %T`, ecnSlopeMinThresholdPercentAttribute))
	}

	pfcDeadlockDetectionTimerAttribute, ok := attributes["pfc_deadlock_detection_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pfc_deadlock_detection_timer is missing from object`)

		return nil, diags
	}

	pfcDeadlockDetectionTimerVal, ok := pfcDeadlockDetectionTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pfc_deadlock_detection_timer expected to be basetypes.Int64Value, was: %T`, pfcDeadlockDetectionTimerAttribute))
	}

	pfcDeadlockRecoveryTimerAttribute, ok := attributes["pfc_deadlock_recovery_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pfc_deadlock_recovery_timer is missing from object`)

		return nil, diags
	}

	pfcDeadlockRecoveryTimerVal, ok := pfcDeadlockRecoveryTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pfc_deadlock_recovery_timer expected to be basetypes.Int64Value, was: %T`, pfcDeadlockRecoveryTimerAttribute))
	}

	queueMaximumBurstSizeAttribute, ok := attributes["queue_maximum_burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queue_maximum_burst_size is missing from object`)

		return nil, diags
	}

	queueMaximumBurstSizeVal, ok := queueMaximumBurstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queue_maximum_burst_size expected to be basetypes.Int64Value, was: %T`, queueMaximumBurstSizeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Rocev2QosValue{
		EcnMaxDropProbabilityPercent: ecnMaxDropProbabilityPercentVal,
		EcnSlopeMaxThresholdPercent:  ecnSlopeMaxThresholdPercentVal,
		EcnSlopeMinThresholdPercent:  ecnSlopeMinThresholdPercentVal,
		PfcDeadlockDetectionTimer:    pfcDeadlockDetectionTimerVal,
		PfcDeadlockRecoveryTimer:     pfcDeadlockRecoveryTimerVal,
		QueueMaximumBurstSize:        queueMaximumBurstSizeVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewRocev2QosValueNull() Rocev2QosValue {
	return Rocev2QosValue{
		state: attr.ValueStateNull,
	}
}

func NewRocev2QosValueUnknown() Rocev2QosValue {
	return Rocev2QosValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRocev2QosValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Rocev2QosValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Rocev2QosValue Attribute Value",
				"While creating a Rocev2QosValue value, a missing attribute value was detected. "+
					"A Rocev2QosValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Rocev2QosValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Rocev2QosValue Attribute Type",
				"While creating a Rocev2QosValue value, an invalid attribute value was detected. "+
					"A Rocev2QosValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Rocev2QosValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Rocev2QosValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Rocev2QosValue Attribute Value",
				"While creating a Rocev2QosValue value, an extra attribute value was detected. "+
					"A Rocev2QosValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Rocev2QosValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRocev2QosValueUnknown(), diags
	}

	ecnMaxDropProbabilityPercentAttribute, ok := attributes["ecn_max_drop_probability_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ecn_max_drop_probability_percent is missing from object`)

		return NewRocev2QosValueUnknown(), diags
	}

	ecnMaxDropProbabilityPercentVal, ok := ecnMaxDropProbabilityPercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ecn_max_drop_probability_percent expected to be basetypes.Int64Value, was: %T`, ecnMaxDropProbabilityPercentAttribute))
	}

	ecnSlopeMaxThresholdPercentAttribute, ok := attributes["ecn_slope_max_threshold_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ecn_slope_max_threshold_percent is missing from object`)

		return NewRocev2QosValueUnknown(), diags
	}

	ecnSlopeMaxThresholdPercentVal, ok := ecnSlopeMaxThresholdPercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ecn_slope_max_threshold_percent expected to be basetypes.Int64Value, was: %T`, ecnSlopeMaxThresholdPercentAttribute))
	}

	ecnSlopeMinThresholdPercentAttribute, ok := attributes["ecn_slope_min_threshold_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ecn_slope_min_threshold_percent is missing from object`)

		return NewRocev2QosValueUnknown(), diags
	}

	ecnSlopeMinThresholdPercentVal, ok := ecnSlopeMinThresholdPercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ecn_slope_min_threshold_percent expected to be basetypes.Int64Value, was: %T`, ecnSlopeMinThresholdPercentAttribute))
	}

	pfcDeadlockDetectionTimerAttribute, ok := attributes["pfc_deadlock_detection_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pfc_deadlock_detection_timer is missing from object`)

		return NewRocev2QosValueUnknown(), diags
	}

	pfcDeadlockDetectionTimerVal, ok := pfcDeadlockDetectionTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pfc_deadlock_detection_timer expected to be basetypes.Int64Value, was: %T`, pfcDeadlockDetectionTimerAttribute))
	}

	pfcDeadlockRecoveryTimerAttribute, ok := attributes["pfc_deadlock_recovery_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pfc_deadlock_recovery_timer is missing from object`)

		return NewRocev2QosValueUnknown(), diags
	}

	pfcDeadlockRecoveryTimerVal, ok := pfcDeadlockRecoveryTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pfc_deadlock_recovery_timer expected to be basetypes.Int64Value, was: %T`, pfcDeadlockRecoveryTimerAttribute))
	}

	queueMaximumBurstSizeAttribute, ok := attributes["queue_maximum_burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queue_maximum_burst_size is missing from object`)

		return NewRocev2QosValueUnknown(), diags
	}

	queueMaximumBurstSizeVal, ok := queueMaximumBurstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queue_maximum_burst_size expected to be basetypes.Int64Value, was: %T`, queueMaximumBurstSizeAttribute))
	}

	if diags.HasError() {
		return NewRocev2QosValueUnknown(), diags
	}

	return Rocev2QosValue{
		EcnMaxDropProbabilityPercent: ecnMaxDropProbabilityPercentVal,
		EcnSlopeMaxThresholdPercent:  ecnSlopeMaxThresholdPercentVal,
		EcnSlopeMinThresholdPercent:  ecnSlopeMinThresholdPercentVal,
		PfcDeadlockDetectionTimer:    pfcDeadlockDetectionTimerVal,
		PfcDeadlockRecoveryTimer:     pfcDeadlockRecoveryTimerVal,
		QueueMaximumBurstSize:        queueMaximumBurstSizeVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewRocev2QosValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Rocev2QosValue {
	object, diags := NewRocev2QosValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRocev2QosValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Rocev2QosType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRocev2QosValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRocev2QosValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRocev2QosValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRocev2QosValueMust(Rocev2QosValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Rocev2QosType) ValueType(ctx context.Context) attr.Value {
	return Rocev2QosValue{}
}

var _ basetypes.ObjectValuable = Rocev2QosValue{}

type Rocev2QosValue struct {
	EcnMaxDropProbabilityPercent basetypes.Int64Value `tfsdk:"ecn_max_drop_probability_percent"`
	EcnSlopeMaxThresholdPercent  basetypes.Int64Value `tfsdk:"ecn_slope_max_threshold_percent"`
	EcnSlopeMinThresholdPercent  basetypes.Int64Value `tfsdk:"ecn_slope_min_threshold_percent"`
	PfcDeadlockDetectionTimer    basetypes.Int64Value `tfsdk:"pfc_deadlock_detection_timer"`
	PfcDeadlockRecoveryTimer     basetypes.Int64Value `tfsdk:"pfc_deadlock_recovery_timer"`
	QueueMaximumBurstSize        basetypes.Int64Value `tfsdk:"queue_maximum_burst_size"`
	state                        attr.ValueState
}

func (v Rocev2QosValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["ecn_max_drop_probability_percent"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ecn_slope_max_threshold_percent"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ecn_slope_min_threshold_percent"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["pfc_deadlock_detection_timer"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["pfc_deadlock_recovery_timer"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["queue_maximum_burst_size"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.EcnMaxDropProbabilityPercent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ecn_max_drop_probability_percent"] = val

		val, err = v.EcnSlopeMaxThresholdPercent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ecn_slope_max_threshold_percent"] = val

		val, err = v.EcnSlopeMinThresholdPercent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ecn_slope_min_threshold_percent"] = val

		val, err = v.PfcDeadlockDetectionTimer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pfc_deadlock_detection_timer"] = val

		val, err = v.PfcDeadlockRecoveryTimer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pfc_deadlock_recovery_timer"] = val

		val, err = v.QueueMaximumBurstSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["queue_maximum_burst_size"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Rocev2QosValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Rocev2QosValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Rocev2QosValue) String() string {
	return "Rocev2QosValue"
}

func (v Rocev2QosValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ecn_max_drop_probability_percent": basetypes.Int64Type{},
		"ecn_slope_max_threshold_percent":  basetypes.Int64Type{},
		"ecn_slope_min_threshold_percent":  basetypes.Int64Type{},
		"pfc_deadlock_detection_timer":     basetypes.Int64Type{},
		"pfc_deadlock_recovery_timer":      basetypes.Int64Type{},
		"queue_maximum_burst_size":         basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ecn_max_drop_probability_percent": v.EcnMaxDropProbabilityPercent,
			"ecn_slope_max_threshold_percent":  v.EcnSlopeMaxThresholdPercent,
			"ecn_slope_min_threshold_percent":  v.EcnSlopeMinThresholdPercent,
			"pfc_deadlock_detection_timer":     v.PfcDeadlockDetectionTimer,
			"pfc_deadlock_recovery_timer":      v.PfcDeadlockRecoveryTimer,
			"queue_maximum_burst_size":         v.QueueMaximumBurstSize,
		})

	return objVal, diags
}

func (v Rocev2QosValue) Equal(o attr.Value) bool {
	other, ok := o.(Rocev2QosValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EcnMaxDropProbabilityPercent.Equal(other.EcnMaxDropProbabilityPercent) {
		return false
	}

	if !v.EcnSlopeMaxThresholdPercent.Equal(other.EcnSlopeMaxThresholdPercent) {
		return false
	}

	if !v.EcnSlopeMinThresholdPercent.Equal(other.EcnSlopeMinThresholdPercent) {
		return false
	}

	if !v.PfcDeadlockDetectionTimer.Equal(other.PfcDeadlockDetectionTimer) {
		return false
	}

	if !v.PfcDeadlockRecoveryTimer.Equal(other.PfcDeadlockRecoveryTimer) {
		return false
	}

	if !v.QueueMaximumBurstSize.Equal(other.QueueMaximumBurstSize) {
		return false
	}

	return true
}

func (v Rocev2QosValue) Type(ctx context.Context) attr.Type {
	return Rocev2QosType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Rocev2QosValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ecn_max_drop_probability_percent": basetypes.Int64Type{},
		"ecn_slope_max_threshold_percent":  basetypes.Int64Type{},
		"ecn_slope_min_threshold_percent":  basetypes.Int64Type{},
		"pfc_deadlock_detection_timer":     basetypes.Int64Type{},
		"pfc_deadlock_recovery_timer":      basetypes.Int64Type{},
		"queue_maximum_burst_size":         basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = StripeConnectorType{}

type StripeConnectorType struct {
	basetypes.ObjectType
}

func (t StripeConnectorType) Equal(o attr.Type) bool {
	other, ok := o.(StripeConnectorType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StripeConnectorType) String() string {
	return "StripeConnectorType"
}

func (t StripeConnectorType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asnPoolAttribute, ok := attributes["asn_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn_pool is missing from object`)

		return nil, diags
	}

	asnPoolVal, ok := asnPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn_pool expected to be basetypes.StringValue, was: %T`, asnPoolAttribute))
	}

	linkSelectorAttribute, ok := attributes["link_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_selector is missing from object`)

		return nil, diags
	}

	linkSelectorVal, ok := linkSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_selector expected to be basetypes.ListValue, was: %T`, linkSelectorAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeSelectorAttribute, ok := attributes["node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selector is missing from object`)

		return nil, diags
	}

	nodeSelectorVal, ok := nodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selector expected to be basetypes.ListValue, was: %T`, nodeSelectorAttribute))
	}

	systemPoolIpv4Attribute, ok := attributes["system_pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv4 is missing from object`)

		return nil, diags
	}

	systemPoolIpv4Val, ok := systemPoolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv4 expected to be basetypes.StringValue, was: %T`, systemPoolIpv4Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StripeConnectorValue{
		AsnPool:        asnPoolVal,
		LinkSelector:   linkSelectorVal,
		Name:           nameVal,
		NodeSelector:   nodeSelectorVal,
		SystemPoolIpv4: systemPoolIpv4Val,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewStripeConnectorValueNull() StripeConnectorValue {
	return StripeConnectorValue{
		state: attr.ValueStateNull,
	}
}

func NewStripeConnectorValueUnknown() StripeConnectorValue {
	return StripeConnectorValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStripeConnectorValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StripeConnectorValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StripeConnectorValue Attribute Value",
				"While creating a StripeConnectorValue value, a missing attribute value was detected. "+
					"A StripeConnectorValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StripeConnectorValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StripeConnectorValue Attribute Type",
				"While creating a StripeConnectorValue value, an invalid attribute value was detected. "+
					"A StripeConnectorValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StripeConnectorValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StripeConnectorValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StripeConnectorValue Attribute Value",
				"While creating a StripeConnectorValue value, an extra attribute value was detected. "+
					"A StripeConnectorValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StripeConnectorValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStripeConnectorValueUnknown(), diags
	}

	asnPoolAttribute, ok := attributes["asn_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn_pool is missing from object`)

		return NewStripeConnectorValueUnknown(), diags
	}

	asnPoolVal, ok := asnPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn_pool expected to be basetypes.StringValue, was: %T`, asnPoolAttribute))
	}

	linkSelectorAttribute, ok := attributes["link_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_selector is missing from object`)

		return NewStripeConnectorValueUnknown(), diags
	}

	linkSelectorVal, ok := linkSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_selector expected to be basetypes.ListValue, was: %T`, linkSelectorAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewStripeConnectorValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeSelectorAttribute, ok := attributes["node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selector is missing from object`)

		return NewStripeConnectorValueUnknown(), diags
	}

	nodeSelectorVal, ok := nodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selector expected to be basetypes.ListValue, was: %T`, nodeSelectorAttribute))
	}

	systemPoolIpv4Attribute, ok := attributes["system_pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv4 is missing from object`)

		return NewStripeConnectorValueUnknown(), diags
	}

	systemPoolIpv4Val, ok := systemPoolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv4 expected to be basetypes.StringValue, was: %T`, systemPoolIpv4Attribute))
	}

	if diags.HasError() {
		return NewStripeConnectorValueUnknown(), diags
	}

	return StripeConnectorValue{
		AsnPool:        asnPoolVal,
		LinkSelector:   linkSelectorVal,
		Name:           nameVal,
		NodeSelector:   nodeSelectorVal,
		SystemPoolIpv4: systemPoolIpv4Val,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewStripeConnectorValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StripeConnectorValue {
	object, diags := NewStripeConnectorValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStripeConnectorValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StripeConnectorType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStripeConnectorValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStripeConnectorValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStripeConnectorValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStripeConnectorValueMust(StripeConnectorValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StripeConnectorType) ValueType(ctx context.Context) attr.Value {
	return StripeConnectorValue{}
}

var _ basetypes.ObjectValuable = StripeConnectorValue{}

type StripeConnectorValue struct {
	AsnPool        basetypes.StringValue `tfsdk:"asn_pool"`
	LinkSelector   basetypes.ListValue   `tfsdk:"link_selector"`
	Name           basetypes.StringValue `tfsdk:"name"`
	NodeSelector   basetypes.ListValue   `tfsdk:"node_selector"`
	SystemPoolIpv4 basetypes.StringValue `tfsdk:"system_pool_ipv4"`
	state          attr.ValueState
}

func (v StripeConnectorValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["asn_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["link_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["system_pool_ipv4"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AsnPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asn_pool"] = val

		val, err = v.LinkSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["link_selector"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NodeSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_selector"] = val

		val, err = v.SystemPoolIpv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_pool_ipv4"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StripeConnectorValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StripeConnectorValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StripeConnectorValue) String() string {
	return "StripeConnectorValue"
}

func (v StripeConnectorValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var linkSelectorVal basetypes.ListValue
	switch {
	case v.LinkSelector.IsUnknown():
		linkSelectorVal = types.ListUnknown(types.StringType)
	case v.LinkSelector.IsNull():
		linkSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		linkSelectorVal, d = types.ListValue(types.StringType, v.LinkSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"asn_pool": basetypes.StringType{},
			"link_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"name": basetypes.StringType{},
			"node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"system_pool_ipv4": basetypes.StringType{},
		}), diags
	}

	var nodeSelectorVal basetypes.ListValue
	switch {
	case v.NodeSelector.IsUnknown():
		nodeSelectorVal = types.ListUnknown(types.StringType)
	case v.NodeSelector.IsNull():
		nodeSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodeSelectorVal, d = types.ListValue(types.StringType, v.NodeSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"asn_pool": basetypes.StringType{},
			"link_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"name": basetypes.StringType{},
			"node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"system_pool_ipv4": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"asn_pool": basetypes.StringType{},
		"link_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"name": basetypes.StringType{},
		"node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"system_pool_ipv4": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"asn_pool":         v.AsnPool,
			"link_selector":    linkSelectorVal,
			"name":             v.Name,
			"node_selector":    nodeSelectorVal,
			"system_pool_ipv4": v.SystemPoolIpv4,
		})

	return objVal, diags
}

func (v StripeConnectorValue) Equal(o attr.Value) bool {
	other, ok := o.(StripeConnectorValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsnPool.Equal(other.AsnPool) {
		return false
	}

	if !v.LinkSelector.Equal(other.LinkSelector) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NodeSelector.Equal(other.NodeSelector) {
		return false
	}

	if !v.SystemPoolIpv4.Equal(other.SystemPoolIpv4) {
		return false
	}

	return true
}

func (v StripeConnectorValue) Type(ctx context.Context) attr.Type {
	return StripeConnectorType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StripeConnectorValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"asn_pool": basetypes.StringType{},
		"link_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"name": basetypes.StringType{},
		"node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"system_pool_ipv4": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StripesType{}

type StripesType struct {
	basetypes.ObjectType
}

func (t StripesType) Equal(o attr.Type) bool {
	other, ok := o.(StripesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StripesType) String() string {
	return "StripesType"
}

func (t StripesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asnPoolAttribute, ok := attributes["asn_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn_pool is missing from object`)

		return nil, diags
	}

	asnPoolVal, ok := asnPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn_pool expected to be basetypes.StringValue, was: %T`, asnPoolAttribute))
	}

	gpuVlanAttribute, ok := attributes["gpu_vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_vlan is missing from object`)

		return nil, diags
	}

	gpuVlanVal, ok := gpuVlanAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_vlan expected to be basetypes.Int64Value, was: %T`, gpuVlanAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeSelectorAttribute, ok := attributes["node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selector is missing from object`)

		return nil, diags
	}

	nodeSelectorVal, ok := nodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selector expected to be basetypes.ListValue, was: %T`, nodeSelectorAttribute))
	}

	stripeIdAttribute, ok := attributes["stripe_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stripe_id is missing from object`)

		return nil, diags
	}

	stripeIdVal, ok := stripeIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stripe_id expected to be basetypes.Int64Value, was: %T`, stripeIdAttribute))
	}

	systemPoolIpv4Attribute, ok := attributes["system_pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv4 is missing from object`)

		return nil, diags
	}

	systemPoolIpv4Val, ok := systemPoolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv4 expected to be basetypes.StringValue, was: %T`, systemPoolIpv4Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StripesValue{
		AsnPool:        asnPoolVal,
		GpuVlan:        gpuVlanVal,
		Name:           nameVal,
		NodeSelector:   nodeSelectorVal,
		StripeId:       stripeIdVal,
		SystemPoolIpv4: systemPoolIpv4Val,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewStripesValueNull() StripesValue {
	return StripesValue{
		state: attr.ValueStateNull,
	}
}

func NewStripesValueUnknown() StripesValue {
	return StripesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStripesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StripesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StripesValue Attribute Value",
				"While creating a StripesValue value, a missing attribute value was detected. "+
					"A StripesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StripesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StripesValue Attribute Type",
				"While creating a StripesValue value, an invalid attribute value was detected. "+
					"A StripesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StripesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StripesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StripesValue Attribute Value",
				"While creating a StripesValue value, an extra attribute value was detected. "+
					"A StripesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StripesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStripesValueUnknown(), diags
	}

	asnPoolAttribute, ok := attributes["asn_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn_pool is missing from object`)

		return NewStripesValueUnknown(), diags
	}

	asnPoolVal, ok := asnPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn_pool expected to be basetypes.StringValue, was: %T`, asnPoolAttribute))
	}

	gpuVlanAttribute, ok := attributes["gpu_vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_vlan is missing from object`)

		return NewStripesValueUnknown(), diags
	}

	gpuVlanVal, ok := gpuVlanAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_vlan expected to be basetypes.Int64Value, was: %T`, gpuVlanAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewStripesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeSelectorAttribute, ok := attributes["node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selector is missing from object`)

		return NewStripesValueUnknown(), diags
	}

	nodeSelectorVal, ok := nodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selector expected to be basetypes.ListValue, was: %T`, nodeSelectorAttribute))
	}

	stripeIdAttribute, ok := attributes["stripe_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stripe_id is missing from object`)

		return NewStripesValueUnknown(), diags
	}

	stripeIdVal, ok := stripeIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stripe_id expected to be basetypes.Int64Value, was: %T`, stripeIdAttribute))
	}

	systemPoolIpv4Attribute, ok := attributes["system_pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv4 is missing from object`)

		return NewStripesValueUnknown(), diags
	}

	systemPoolIpv4Val, ok := systemPoolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv4 expected to be basetypes.StringValue, was: %T`, systemPoolIpv4Attribute))
	}

	if diags.HasError() {
		return NewStripesValueUnknown(), diags
	}

	return StripesValue{
		AsnPool:        asnPoolVal,
		GpuVlan:        gpuVlanVal,
		Name:           nameVal,
		NodeSelector:   nodeSelectorVal,
		StripeId:       stripeIdVal,
		SystemPoolIpv4: systemPoolIpv4Val,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewStripesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StripesValue {
	object, diags := NewStripesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStripesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StripesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStripesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStripesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStripesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStripesValueMust(StripesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StripesType) ValueType(ctx context.Context) attr.Value {
	return StripesValue{}
}

var _ basetypes.ObjectValuable = StripesValue{}

type StripesValue struct {
	AsnPool        basetypes.StringValue `tfsdk:"asn_pool"`
	GpuVlan        basetypes.Int64Value  `tfsdk:"gpu_vlan"`
	Name           basetypes.StringValue `tfsdk:"name"`
	NodeSelector   basetypes.ListValue   `tfsdk:"node_selector"`
	StripeId       basetypes.Int64Value  `tfsdk:"stripe_id"`
	SystemPoolIpv4 basetypes.StringValue `tfsdk:"system_pool_ipv4"`
	state          attr.ValueState
}

func (v StripesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["asn_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gpu_vlan"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["stripe_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["system_pool_ipv4"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.AsnPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asn_pool"] = val

		val, err = v.GpuVlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_vlan"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NodeSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_selector"] = val

		val, err = v.StripeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stripe_id"] = val

		val, err = v.SystemPoolIpv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_pool_ipv4"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StripesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StripesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StripesValue) String() string {
	return "StripesValue"
}

func (v StripesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var nodeSelectorVal basetypes.ListValue
	switch {
	case v.NodeSelector.IsUnknown():
		nodeSelectorVal = types.ListUnknown(types.StringType)
	case v.NodeSelector.IsNull():
		nodeSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodeSelectorVal, d = types.ListValue(types.StringType, v.NodeSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"asn_pool": basetypes.StringType{},
			"gpu_vlan": basetypes.Int64Type{},
			"name":     basetypes.StringType{},
			"node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"stripe_id":        basetypes.Int64Type{},
			"system_pool_ipv4": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"asn_pool": basetypes.StringType{},
		"gpu_vlan": basetypes.Int64Type{},
		"name":     basetypes.StringType{},
		"node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"stripe_id":        basetypes.Int64Type{},
		"system_pool_ipv4": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"asn_pool":         v.AsnPool,
			"gpu_vlan":         v.GpuVlan,
			"name":             v.Name,
			"node_selector":    nodeSelectorVal,
			"stripe_id":        v.StripeId,
			"system_pool_ipv4": v.SystemPoolIpv4,
		})

	return objVal, diags
}

func (v StripesValue) Equal(o attr.Value) bool {
	other, ok := o.(StripesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsnPool.Equal(other.AsnPool) {
		return false
	}

	if !v.GpuVlan.Equal(other.GpuVlan) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NodeSelector.Equal(other.NodeSelector) {
		return false
	}

	if !v.StripeId.Equal(other.StripeId) {
		return false
	}

	if !v.SystemPoolIpv4.Equal(other.SystemPoolIpv4) {
		return false
	}

	return true
}

func (v StripesValue) Type(ctx context.Context) attr.Type {
	return StripesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StripesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"asn_pool": basetypes.StringType{},
		"gpu_vlan": basetypes.Int64Type{},
		"name":     basetypes.StringType{},
		"node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"stripe_id":        basetypes.Int64Type{},
		"system_pool_ipv4": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return nil, diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return nil, diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	stripeConnector1Attribute, ok := attributes["stripe_connector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stripe_connector_1 is missing from object`)

		return nil, diags
	}

	stripeConnector1Val, ok := stripeConnector1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stripe_connector_1 expected to be basetypes.ObjectValue, was: %T`, stripeConnector1Attribute))
	}

	stripes1Attribute, ok := attributes["stripes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stripes_1 is missing from object`)

		return nil, diags
	}

	stripes1Val, ok := stripes1Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stripes_1 expected to be basetypes.ListValue, was: %T`, stripes1Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Health:            healthVal,
		HealthScoreReason: healthScoreReasonVal,
		LastChange:        lastChangeVal,
		OperationalState:  operationalStateVal,
		StripeConnector1:  stripeConnector1Val,
		Stripes1:          stripes1Val,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	stripeConnector1Attribute, ok := attributes["stripe_connector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stripe_connector_1 is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	stripeConnector1Val, ok := stripeConnector1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stripe_connector_1 expected to be basetypes.ObjectValue, was: %T`, stripeConnector1Attribute))
	}

	stripes1Attribute, ok := attributes["stripes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stripes_1 is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	stripes1Val, ok := stripes1Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stripes_1 expected to be basetypes.ListValue, was: %T`, stripes1Attribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Health:            healthVal,
		HealthScoreReason: healthScoreReasonVal,
		LastChange:        lastChangeVal,
		OperationalState:  operationalStateVal,
		StripeConnector1:  stripeConnector1Val,
		Stripes1:          stripes1Val,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Health            basetypes.Int64Value  `tfsdk:"health"`
	HealthScoreReason basetypes.StringValue `tfsdk:"health_score_reason"`
	LastChange        basetypes.StringValue `tfsdk:"last_change"`
	OperationalState  basetypes.StringValue `tfsdk:"operational_state"`
	StripeConnector1  basetypes.ObjectValue `tfsdk:"stripe_connector"`
	Stripes1          basetypes.ListValue   `tfsdk:"stripes"`
	state             attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["health"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["health_score_reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["stripe_connector"] = basetypes.ObjectType{
		AttrTypes: StripeConnector1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["stripes"] = basetypes.ListType{
		ElemType: Stripes1Value{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Health.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health"] = val

		val, err = v.HealthScoreReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_score_reason"] = val

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		val, err = v.StripeConnector1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stripe_connector"] = val

		val, err = v.Stripes1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stripes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var stripeConnector1 basetypes.ObjectValue

	if v.StripeConnector1.IsNull() {
		stripeConnector1 = types.ObjectNull(
			StripeConnector1Value{}.AttributeTypes(ctx),
		)
	}

	if v.StripeConnector1.IsUnknown() {
		stripeConnector1 = types.ObjectUnknown(
			StripeConnector1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.StripeConnector1.IsNull() && !v.StripeConnector1.IsUnknown() {
		stripeConnector1 = types.ObjectValueMust(
			StripeConnector1Value{}.AttributeTypes(ctx),
			v.StripeConnector1.Attributes(),
		)
	}

	stripes1 := types.ListValueMust(
		Stripes1Type{
			basetypes.ObjectType{
				AttrTypes: Stripes1Value{}.AttributeTypes(ctx),
			},
		},
		v.Stripes1.Elements(),
	)

	if v.Stripes1.IsNull() {
		stripes1 = types.ListNull(
			Stripes1Type{
				basetypes.ObjectType{
					AttrTypes: Stripes1Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Stripes1.IsUnknown() {
		stripes1 = types.ListUnknown(
			Stripes1Type{
				basetypes.ObjectType{
					AttrTypes: Stripes1Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"operational_state":   basetypes.StringType{},
		"stripe_connector": basetypes.ObjectType{
			AttrTypes: StripeConnector1Value{}.AttributeTypes(ctx),
		},
		"stripes": basetypes.ListType{
			ElemType: Stripes1Value{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"health":              v.Health,
			"health_score_reason": v.HealthScoreReason,
			"last_change":         v.LastChange,
			"operational_state":   v.OperationalState,
			"stripe_connector":    stripeConnector1,
			"stripes":             stripes1,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Health.Equal(other.Health) {
		return false
	}

	if !v.HealthScoreReason.Equal(other.HealthScoreReason) {
		return false
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	if !v.StripeConnector1.Equal(other.StripeConnector1) {
		return false
	}

	if !v.Stripes1.Equal(other.Stripes1) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"operational_state":   basetypes.StringType{},
		"stripe_connector": basetypes.ObjectType{
			AttrTypes: StripeConnector1Value{}.AttributeTypes(ctx),
		},
		"stripes": basetypes.ListType{
			ElemType: Stripes1Value{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = StripeConnector1Type{}

type StripeConnector1Type struct {
	basetypes.ObjectType
}

func (t StripeConnector1Type) Equal(o attr.Type) bool {
	other, ok := o.(StripeConnector1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StripeConnector1Type) String() string {
	return "StripeConnector1Type"
}

func (t StripeConnector1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	stripeConnectorNodesAttribute, ok := attributes["stripe_connector_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stripe_connector_nodes is missing from object`)

		return nil, diags
	}

	stripeConnectorNodesVal, ok := stripeConnectorNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stripe_connector_nodes expected to be basetypes.ListValue, was: %T`, stripeConnectorNodesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StripeConnector1Value{
		Name:                 nameVal,
		StripeConnectorNodes: stripeConnectorNodesVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewStripeConnector1ValueNull() StripeConnector1Value {
	return StripeConnector1Value{
		state: attr.ValueStateNull,
	}
}

func NewStripeConnector1ValueUnknown() StripeConnector1Value {
	return StripeConnector1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewStripeConnector1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StripeConnector1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StripeConnector1Value Attribute Value",
				"While creating a StripeConnector1Value value, a missing attribute value was detected. "+
					"A StripeConnector1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StripeConnector1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StripeConnector1Value Attribute Type",
				"While creating a StripeConnector1Value value, an invalid attribute value was detected. "+
					"A StripeConnector1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StripeConnector1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StripeConnector1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StripeConnector1Value Attribute Value",
				"While creating a StripeConnector1Value value, an extra attribute value was detected. "+
					"A StripeConnector1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StripeConnector1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStripeConnector1ValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewStripeConnector1ValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	stripeConnectorNodesAttribute, ok := attributes["stripe_connector_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stripe_connector_nodes is missing from object`)

		return NewStripeConnector1ValueUnknown(), diags
	}

	stripeConnectorNodesVal, ok := stripeConnectorNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stripe_connector_nodes expected to be basetypes.ListValue, was: %T`, stripeConnectorNodesAttribute))
	}

	if diags.HasError() {
		return NewStripeConnector1ValueUnknown(), diags
	}

	return StripeConnector1Value{
		Name:                 nameVal,
		StripeConnectorNodes: stripeConnectorNodesVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewStripeConnector1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StripeConnector1Value {
	object, diags := NewStripeConnector1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStripeConnector1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StripeConnector1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStripeConnector1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStripeConnector1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStripeConnector1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStripeConnector1ValueMust(StripeConnector1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t StripeConnector1Type) ValueType(ctx context.Context) attr.Value {
	return StripeConnector1Value{}
}

var _ basetypes.ObjectValuable = StripeConnector1Value{}

type StripeConnector1Value struct {
	Name                 basetypes.StringValue `tfsdk:"name"`
	StripeConnectorNodes basetypes.ListValue   `tfsdk:"stripe_connector_nodes"`
	state                attr.ValueState
}

func (v StripeConnector1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["stripe_connector_nodes"] = basetypes.ListType{
		ElemType: StripeConnectorNodesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.StripeConnectorNodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stripe_connector_nodes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StripeConnector1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StripeConnector1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StripeConnector1Value) String() string {
	return "StripeConnector1Value"
}

func (v StripeConnector1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	stripeConnectorNodes := types.ListValueMust(
		StripeConnectorNodesType{
			basetypes.ObjectType{
				AttrTypes: StripeConnectorNodesValue{}.AttributeTypes(ctx),
			},
		},
		v.StripeConnectorNodes.Elements(),
	)

	if v.StripeConnectorNodes.IsNull() {
		stripeConnectorNodes = types.ListNull(
			StripeConnectorNodesType{
				basetypes.ObjectType{
					AttrTypes: StripeConnectorNodesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.StripeConnectorNodes.IsUnknown() {
		stripeConnectorNodes = types.ListUnknown(
			StripeConnectorNodesType{
				basetypes.ObjectType{
					AttrTypes: StripeConnectorNodesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"stripe_connector_nodes": basetypes.ListType{
			ElemType: StripeConnectorNodesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":                   v.Name,
			"stripe_connector_nodes": stripeConnectorNodes,
		})

	return objVal, diags
}

func (v StripeConnector1Value) Equal(o attr.Value) bool {
	other, ok := o.(StripeConnector1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.StripeConnectorNodes.Equal(other.StripeConnectorNodes) {
		return false
	}

	return true
}

func (v StripeConnector1Value) Type(ctx context.Context) attr.Type {
	return StripeConnector1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StripeConnector1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"stripe_connector_nodes": basetypes.ListType{
			ElemType: StripeConnectorNodesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = StripeConnectorNodesType{}

type StripeConnectorNodesType struct {
	basetypes.ObjectType
}

func (t StripeConnectorNodesType) Equal(o attr.Type) bool {
	other, ok := o.(StripeConnectorNodesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StripeConnectorNodesType) String() string {
	return "StripeConnectorNodesType"
}

func (t StripeConnectorNodesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return nil, diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	operatingSystemVersionAttribute, ok := attributes["operating_system_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system_version is missing from object`)

		return nil, diags
	}

	operatingSystemVersionVal, ok := operatingSystemVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system_version expected to be basetypes.StringValue, was: %T`, operatingSystemVersionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StripeConnectorNodesValue{
		Node:                   nodeVal,
		OperatingSystem:        operatingSystemVal,
		OperatingSystemVersion: operatingSystemVersionVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewStripeConnectorNodesValueNull() StripeConnectorNodesValue {
	return StripeConnectorNodesValue{
		state: attr.ValueStateNull,
	}
}

func NewStripeConnectorNodesValueUnknown() StripeConnectorNodesValue {
	return StripeConnectorNodesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStripeConnectorNodesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StripeConnectorNodesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StripeConnectorNodesValue Attribute Value",
				"While creating a StripeConnectorNodesValue value, a missing attribute value was detected. "+
					"A StripeConnectorNodesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StripeConnectorNodesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StripeConnectorNodesValue Attribute Type",
				"While creating a StripeConnectorNodesValue value, an invalid attribute value was detected. "+
					"A StripeConnectorNodesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StripeConnectorNodesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StripeConnectorNodesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StripeConnectorNodesValue Attribute Value",
				"While creating a StripeConnectorNodesValue value, an extra attribute value was detected. "+
					"A StripeConnectorNodesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StripeConnectorNodesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStripeConnectorNodesValueUnknown(), diags
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewStripeConnectorNodesValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return NewStripeConnectorNodesValueUnknown(), diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	operatingSystemVersionAttribute, ok := attributes["operating_system_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system_version is missing from object`)

		return NewStripeConnectorNodesValueUnknown(), diags
	}

	operatingSystemVersionVal, ok := operatingSystemVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system_version expected to be basetypes.StringValue, was: %T`, operatingSystemVersionAttribute))
	}

	if diags.HasError() {
		return NewStripeConnectorNodesValueUnknown(), diags
	}

	return StripeConnectorNodesValue{
		Node:                   nodeVal,
		OperatingSystem:        operatingSystemVal,
		OperatingSystemVersion: operatingSystemVersionVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewStripeConnectorNodesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StripeConnectorNodesValue {
	object, diags := NewStripeConnectorNodesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStripeConnectorNodesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StripeConnectorNodesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStripeConnectorNodesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStripeConnectorNodesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStripeConnectorNodesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStripeConnectorNodesValueMust(StripeConnectorNodesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StripeConnectorNodesType) ValueType(ctx context.Context) attr.Value {
	return StripeConnectorNodesValue{}
}

var _ basetypes.ObjectValuable = StripeConnectorNodesValue{}

type StripeConnectorNodesValue struct {
	Node                   basetypes.StringValue `tfsdk:"node"`
	OperatingSystem        basetypes.StringValue `tfsdk:"operating_system"`
	OperatingSystemVersion basetypes.StringValue `tfsdk:"operating_system_version"`
	state                  attr.ValueState
}

func (v StripeConnectorNodesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_system"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_system_version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		val, err = v.OperatingSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system"] = val

		val, err = v.OperatingSystemVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system_version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StripeConnectorNodesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StripeConnectorNodesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StripeConnectorNodesValue) String() string {
	return "StripeConnectorNodesValue"
}

func (v StripeConnectorNodesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"node":                     basetypes.StringType{},
		"operating_system":         basetypes.StringType{},
		"operating_system_version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"node":                     v.Node,
			"operating_system":         v.OperatingSystem,
			"operating_system_version": v.OperatingSystemVersion,
		})

	return objVal, diags
}

func (v StripeConnectorNodesValue) Equal(o attr.Value) bool {
	other, ok := o.(StripeConnectorNodesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	if !v.OperatingSystem.Equal(other.OperatingSystem) {
		return false
	}

	if !v.OperatingSystemVersion.Equal(other.OperatingSystemVersion) {
		return false
	}

	return true
}

func (v StripeConnectorNodesValue) Type(ctx context.Context) attr.Type {
	return StripeConnectorNodesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StripeConnectorNodesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"node":                     basetypes.StringType{},
		"operating_system":         basetypes.StringType{},
		"operating_system_version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Stripes1Type{}

type Stripes1Type struct {
	basetypes.ObjectType
}

func (t Stripes1Type) Equal(o attr.Type) bool {
	other, ok := o.(Stripes1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Stripes1Type) String() string {
	return "Stripes1Type"
}

func (t Stripes1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	leafNodesAttribute, ok := attributes["leaf_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`leaf_nodes is missing from object`)

		return nil, diags
	}

	leafNodesVal, ok := leafNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`leaf_nodes expected to be basetypes.ListValue, was: %T`, leafNodesAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Stripes1Value{
		LeafNodes: leafNodesVal,
		Name:      nameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewStripes1ValueNull() Stripes1Value {
	return Stripes1Value{
		state: attr.ValueStateNull,
	}
}

func NewStripes1ValueUnknown() Stripes1Value {
	return Stripes1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewStripes1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Stripes1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Stripes1Value Attribute Value",
				"While creating a Stripes1Value value, a missing attribute value was detected. "+
					"A Stripes1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Stripes1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Stripes1Value Attribute Type",
				"While creating a Stripes1Value value, an invalid attribute value was detected. "+
					"A Stripes1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Stripes1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Stripes1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Stripes1Value Attribute Value",
				"While creating a Stripes1Value value, an extra attribute value was detected. "+
					"A Stripes1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Stripes1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStripes1ValueUnknown(), diags
	}

	leafNodesAttribute, ok := attributes["leaf_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`leaf_nodes is missing from object`)

		return NewStripes1ValueUnknown(), diags
	}

	leafNodesVal, ok := leafNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`leaf_nodes expected to be basetypes.ListValue, was: %T`, leafNodesAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewStripes1ValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewStripes1ValueUnknown(), diags
	}

	return Stripes1Value{
		LeafNodes: leafNodesVal,
		Name:      nameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewStripes1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Stripes1Value {
	object, diags := NewStripes1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStripes1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Stripes1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStripes1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStripes1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStripes1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStripes1ValueMust(Stripes1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Stripes1Type) ValueType(ctx context.Context) attr.Value {
	return Stripes1Value{}
}

var _ basetypes.ObjectValuable = Stripes1Value{}

type Stripes1Value struct {
	LeafNodes basetypes.ListValue   `tfsdk:"leaf_nodes"`
	Name      basetypes.StringValue `tfsdk:"name"`
	state     attr.ValueState
}

func (v Stripes1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["leaf_nodes"] = basetypes.ListType{
		ElemType: LeafNodesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.LeafNodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["leaf_nodes"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Stripes1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Stripes1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Stripes1Value) String() string {
	return "Stripes1Value"
}

func (v Stripes1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	leafNodes := types.ListValueMust(
		LeafNodesType{
			basetypes.ObjectType{
				AttrTypes: LeafNodesValue{}.AttributeTypes(ctx),
			},
		},
		v.LeafNodes.Elements(),
	)

	if v.LeafNodes.IsNull() {
		leafNodes = types.ListNull(
			LeafNodesType{
				basetypes.ObjectType{
					AttrTypes: LeafNodesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.LeafNodes.IsUnknown() {
		leafNodes = types.ListUnknown(
			LeafNodesType{
				basetypes.ObjectType{
					AttrTypes: LeafNodesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"leaf_nodes": basetypes.ListType{
			ElemType: LeafNodesValue{}.Type(ctx),
		},
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"leaf_nodes": leafNodes,
			"name":       v.Name,
		})

	return objVal, diags
}

func (v Stripes1Value) Equal(o attr.Value) bool {
	other, ok := o.(Stripes1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LeafNodes.Equal(other.LeafNodes) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v Stripes1Value) Type(ctx context.Context) attr.Type {
	return Stripes1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Stripes1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"leaf_nodes": basetypes.ListType{
			ElemType: LeafNodesValue{}.Type(ctx),
		},
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LeafNodesType{}

type LeafNodesType struct {
	basetypes.ObjectType
}

func (t LeafNodesType) Equal(o attr.Type) bool {
	other, ok := o.(LeafNodesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LeafNodesType) String() string {
	return "LeafNodesType"
}

func (t LeafNodesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return nil, diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	operatingSystemVersionAttribute, ok := attributes["operating_system_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system_version is missing from object`)

		return nil, diags
	}

	operatingSystemVersionVal, ok := operatingSystemVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system_version expected to be basetypes.StringValue, was: %T`, operatingSystemVersionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LeafNodesValue{
		Node:                   nodeVal,
		OperatingSystem:        operatingSystemVal,
		OperatingSystemVersion: operatingSystemVersionVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewLeafNodesValueNull() LeafNodesValue {
	return LeafNodesValue{
		state: attr.ValueStateNull,
	}
}

func NewLeafNodesValueUnknown() LeafNodesValue {
	return LeafNodesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLeafNodesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LeafNodesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LeafNodesValue Attribute Value",
				"While creating a LeafNodesValue value, a missing attribute value was detected. "+
					"A LeafNodesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LeafNodesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LeafNodesValue Attribute Type",
				"While creating a LeafNodesValue value, an invalid attribute value was detected. "+
					"A LeafNodesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LeafNodesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LeafNodesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LeafNodesValue Attribute Value",
				"While creating a LeafNodesValue value, an extra attribute value was detected. "+
					"A LeafNodesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LeafNodesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLeafNodesValueUnknown(), diags
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewLeafNodesValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return NewLeafNodesValueUnknown(), diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	operatingSystemVersionAttribute, ok := attributes["operating_system_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system_version is missing from object`)

		return NewLeafNodesValueUnknown(), diags
	}

	operatingSystemVersionVal, ok := operatingSystemVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system_version expected to be basetypes.StringValue, was: %T`, operatingSystemVersionAttribute))
	}

	if diags.HasError() {
		return NewLeafNodesValueUnknown(), diags
	}

	return LeafNodesValue{
		Node:                   nodeVal,
		OperatingSystem:        operatingSystemVal,
		OperatingSystemVersion: operatingSystemVersionVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewLeafNodesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LeafNodesValue {
	object, diags := NewLeafNodesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLeafNodesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LeafNodesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLeafNodesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLeafNodesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLeafNodesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLeafNodesValueMust(LeafNodesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LeafNodesType) ValueType(ctx context.Context) attr.Value {
	return LeafNodesValue{}
}

var _ basetypes.ObjectValuable = LeafNodesValue{}

type LeafNodesValue struct {
	Node                   basetypes.StringValue `tfsdk:"node"`
	OperatingSystem        basetypes.StringValue `tfsdk:"operating_system"`
	OperatingSystemVersion basetypes.StringValue `tfsdk:"operating_system_version"`
	state                  attr.ValueState
}

func (v LeafNodesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_system"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_system_version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		val, err = v.OperatingSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system"] = val

		val, err = v.OperatingSystemVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system_version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LeafNodesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LeafNodesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LeafNodesValue) String() string {
	return "LeafNodesValue"
}

func (v LeafNodesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"node":                     basetypes.StringType{},
		"operating_system":         basetypes.StringType{},
		"operating_system_version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"node":                     v.Node,
			"operating_system":         v.OperatingSystem,
			"operating_system_version": v.OperatingSystemVersion,
		})

	return objVal, diags
}

func (v LeafNodesValue) Equal(o attr.Value) bool {
	other, ok := o.(LeafNodesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	if !v.OperatingSystem.Equal(other.OperatingSystem) {
		return false
	}

	if !v.OperatingSystemVersion.Equal(other.OperatingSystemVersion) {
		return false
	}

	return true
}

func (v LeafNodesValue) Type(ctx context.Context) attr.Type {
	return LeafNodesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LeafNodesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"node":                     basetypes.StringType{},
		"operating_system":         basetypes.StringType{},
		"operating_system_version": basetypes.StringType{},
	}
}
